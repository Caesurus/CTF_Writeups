//cat /challenge/vuln.c
#include <stdio.h>#include <stdlib.h>#include <time.h>#include <string.h>
#define HORSES_IN_STABLE (18)#define MAX_NAME_LEN (0x100)#define WIN_SPOT (30)#define RAND_DELTA_MIN (1)#define RAND_DELTA_MAX (5)#define HORSES_FOR_RACE (5)#define FINISH_MARK ('|')#define SHOW_LEN (16)
typedef struct Horse {    char *name;    int spot;    int in_use;} horse_ptr;
typedef struct Stable {	horse_ptr horses[HORSES_IN_STABLE];} stable_ptr;
int cheat_used = 0;// get x bytes of user input
void get_input(char *buf, int size) {	char c = '\n';	printf("Enter a string of %d characters: ", size); 	for (int i = 0; i < size; i++) {        c = getchar();		while (c == '\n') {			c = getchar();		}        if (c == '\xff') {            return;        }		*buf++ = c;	}	while ((c = getchar()) != '\n') {}	*buf = '\0';}
// sleepvoid sleep(int seconds) {    // use the system sleep command    char cmd[0x10];    sprintf(cmd, "sleep %d", seconds);    system(cmd);}
// initialize the stablevoid init_stable(stable_ptr *stable) {    for (int i = 0; i < HORSES_IN_STABLE; i++) {        stable->horses[i].name = NULL;        stable->horses[i].spot = i;        stable->horses[i].in_use = 0;    }}
// add a horseint add_horse(stable_ptr *stable) {    int choice = 0;    int name_len = 0;    // get stable location    printf("Stable index # (0-%d)? ", HORSES_IN_STABLE - 1);    scanf("%d", &choice);    // check if stable location is valid    if (choice < 0 || choice >= HORSES_IN_STABLE) {        printf("Invalid stable index\n");        return 0;    }      // check if stable location is in use    if (stable->horses[choice].in_use) {        printf("Stable location already in use\n");        return 0;    }    // get length of horse name    printf("Horse name length (%d-%d)? ", SHOW_LEN, MAX_NAME_LEN);    scanf("%d", &name_len);    // check if name length is valid    if (name_len < SHOW_LEN || name_len > MAX_NAME_LEN) {        printf("Invalid horse name length\n");        return 0;    }    // allocate memory for horse name    stable->horses[choice].name = malloc(name_len + 1);    if (stable->horses[choice].name == NULL) {        printf("Failed to allocate memory for horse name\n");        return 0;    }    // get horse name    get_input(stable->horses[choice].name, name_len);    // set in use flag    stable->horses[choice].in_use = 1;    printf("Added horse to stable index %d\n", choice);    return 1;}
// remove a horseint remove_horse(stable_ptr *stable) {    int choice = 0;    // get stable location    printf("Stable index # (0-%d)? ", HORSES_IN_STABLE - 1);    scanf("%d", &choice);    // check if stable location is valid    if (choice < 0 || choice >= HORSES_IN_STABLE) {        printf("Invalid stable index\n");        return 0;    }    // check if stable location is in use    if (!stable->horses[choice].in_use) {        printf("Stable location not in use\n");        return 0;    }    // free horse name    free(stable->horses[choice].name);    // stable->horses[choice].name = NULL;    // clear in use flag    stable->horses[choice].in_use = 0;    printf("Removed horse from stable index %d\n", choice);    return 1;}
// check if more than 1 horse is in useint check_horses(stable_ptr *stable) {    int count = 0;    for (int i = 0; i < HORSES_IN_STABLE; i++) {        if (stable->horses[i].in_use) {            count++;        }    }    return count >= HORSES_FOR_RACE;}
// check if race has been won by seeing if any horse in use has a spot >= WIN_SPOTint check_win(stable_ptr *stable) {    for (int i = 0; i < HORSES_IN_STABLE; i++) {        if (stable->horses[i].in_use && stable->horses[i].spot >= WIN_SPOT) {            return 1;        }    }    return 0;}
// return the name of the horse with the highest spot valuechar *get_winner(stable_ptr *stable) {    int max = 0;    int max_index = 0;    for (int i = 0; i < HORSES_IN_STABLE; i++) {        if (stable->horses[i].in_use && stable->horses[i].spot > max) {            max = stable->horses[i].spot;            max_index = i;        }    }    return stable->horses[max_index].name;}
// do race round by adding a random number to each horse's spot between RAND_DELTA_MIN and RAND_DELTA_MAXvoid do_round(stable_ptr *stable) {    for (int i = 0; i < HORSES_IN_STABLE; i++) {        if (stable->horses[i].in_use) {            stable->horses[i].spot += rand() % ((RAND_DELTA_MAX + 1) - RAND_DELTA_MIN) + RAND_DELTA_MIN;        }    }}
// print the stable with the name preceded by spaces to show the spot valuevoid print_race(stable_ptr *stable) {    int name_len = 0;    for (int i = 0; i < HORSES_IN_STABLE; i++) {        if (stable->horses[i].in_use) {            name_len = strnlen(stable->horses[i].name, SHOW_LEN);            for (int j = 0; j < stable->horses[i].spot; j++) {                putc(' ', stdout);            }            // print the horses name up to name_len characters            for (int j = 0; j < name_len; j++) {                putc(stable->horses[i].name[j], stdout);            }            // print spaces up until WIN_SPOT            if (stable->horses[i].spot + name_len < WIN_SPOT) {                for (int j = 0; j < WIN_SPOT - stable->horses[i].spot - name_len; j++) {                    putc(' ', stdout);                }                putc(FINISH_MARK, stdout);            }        } else {            for (int j = 0; j < WIN_SPOT; j++) {                putc(' ', stdout);            }            putc(FINISH_MARK, stdout);        }        putc('\n', stdout);    }    printf("\n\n");    sleep(1);}
void cheat(stable_ptr *stable) {    int choice = 0;    int new_spot = 0;    printf("You may try to take a head start, if you get caught you will be banned from the races!\n");    // get stable location    printf("Stable index # (0-%d)? ", HORSES_IN_STABLE - 1);    scanf("%d", &choice);    // check if stable location is valid    if (choice < 0 || choice >= HORSES_IN_STABLE) {        printf("Invalid stable index\n");        return;    }    // get horse name    get_input(stable->horses[choice].name, SHOW_LEN);    // get new spot for horse    printf("New spot? ");    scanf("%d", &new_spot);    stable->horses[choice].spot = new_spot;    printf("Modified horse in stable index %d\n", choice);}
void setup() {    // disable buffering	setbuf(stdin, NULL);	setbuf(stdout, NULL);	setbuf(stderr, NULL);    // seed random with /dev/urandom    FILE *fp = fopen("/dev/urandom", "r");    unsigned int seed = 0;    fread(&seed, sizeof(seed), 1, fp);    fclose(fp);    srand(seed);}
// mainint main(int argc, char **argv) {    stable_ptr *stable = malloc(sizeof(stable_ptr));    int choice = 0;    int done = 0;    // initialize program    setup();    // initialize stable    init_stable(stable);    // print menu with 4 options, add horse, remove horse, race, or exit    while (!done) {        printf("1. Add horse\n");        printf("2. Remove horse\n");        printf("3. Race\n");        printf("4. Exit\n");        printf("Choice: ");        scanf("%d", &choice);        switch (choice) {            case 0:                cheat(stable);                cheat_used = 1;                break;            case 1:                if(!add_horse(stable)) {                    done = 1;                }                break;            case 2:                if(!remove_horse(stable)) {                    done = 1;                }                break;            case 3:                if (cheat_used) {                    printf("You have been caught cheating!\n");                    done = 1;                }                else if (check_horses(stable)) {                    while (!check_win(stable)) {                        do_round(stable);                        print_race(stable);                    }                    // print name of horse with highest spot                    printf("WINNER: %s\n\n", get_winner(stable));                    // clear spots for all horses                    for (int i = 0; i < HORSES_IN_STABLE; i++) {                        stable->horses[i].spot = 0;                    }                } else {                    printf("Not enough horses to race\n");                }                break;            case 4:                done = 1;                break;            default:                printf("Invalid choice\n");                break;        }    }    printf("Goodbye!\n");    return 0;}
